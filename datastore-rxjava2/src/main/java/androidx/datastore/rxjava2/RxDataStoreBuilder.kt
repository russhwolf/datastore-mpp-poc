/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.datastore.rxjava2

import android.annotation.SuppressLint
import android.content.Context
import androidx.datastore.core.DataMigration
import androidx.datastore.core.DataStore
import androidx.datastore.core.DataStoreFactory
import androidx.datastore.core.Serializer
import androidx.datastore.createDataStore
import androidx.datastore.core.handlers.ReplaceFileCorruptionHandler
import io.reactivex.Scheduler
import io.reactivex.schedulers.Schedulers
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.rx2.asCoroutineDispatcher
import java.io.File
import java.util.concurrent.Callable

/**
 * RxSharedPreferencesMigrationBuilder class for a DataStore that works on a single process.
 */
@SuppressLint("TopLevelBuilder")
public class RxDataStoreBuilder<T>() {

    // Either produceFile or context & name must be set, but not both.
    private var produceFile: Callable<File>? = null

    private var context: Context? = null
    private var name: String? = null

    // Required
    private var serializer: Serializer<T>? = null

    // Optional
    private var ioScheduler: Scheduler = Schedulers.io()
    private var corruptionHandler: ReplaceFileCorruptionHandler<T>? = null
    private val dataMigrations: MutableList<DataMigration<T>> = mutableListOf()

    /**
     * Set the callable which returns the File that DataStore acts on. The user is responsible for
     * ensuring that there is never more than one DataStore acting on a file at a time.
     *
     * It is required to call either this method or [setFileName] before calling [build].
     *
     *
     * @param produceFile Function which returns the file that the new DataStore will act on. The
     * function must return the same path every time. No two instances of DataStore should act on
     * the same file at the same time.
     * @throws IllegalStateException if context and name are already set
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setFileProducer(produceFile: Callable<File>): RxDataStoreBuilder<T> = apply {
        check(context == null) { "Only call setFileProducer or setContextAndName" }
        check(name == null) { "Only call setFileProducer or setContextAndName" }
        this.produceFile = produceFile
    }

    /**
     * Set the Context and name from which to derive the DataStore file. The file is generated by
     * See [Context.createDataStore] for more info. The user is responsible for ensuring that
     * there is never more than one DataStore acting on a file at a time.
     *
     * It is required to call either this method or [setFileProducer] before calling [build].
     *
     * @param context the context from which we retrieve files directory.
     * @param fileName the filename relative to Context.filesDir that DataStore acts on. The File is
     * obtained by calling File(context.filesDir, fileName). No two instances of DataStore should
     * act on the same file at the same time.
     * @throws IllegalStateException if produceFile is already set
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setFileName(context: Context, fileName: String): RxDataStoreBuilder<T> =
        apply {
            check(produceFile == null) { "Only call setFileProducer or setContextAndName" }
            this.context = context
            this.name = fileName
        }

    /**
     * Set the serializer that this DataStore acts on.
     *
     * This parameter is required.
     *
     * @param serializer the serializer for the type that this DataStore acts on.
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setSerializer(serializer: Serializer<T>): RxDataStoreBuilder<T> = apply {
        this.serializer = serializer
    }

    /**
     * Set the Scheduler on which to perform IO and transform operations. This is converted into
     * a CoroutineDispatcher before being added to DataStore.
     *
     * This parameter is optional and defaults to Schedulers.io().
     *
     * @param ioScheduler the scheduler on which IO and transform operations are run
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setIoScheduler(ioScheduler: Scheduler): RxDataStoreBuilder<T> =
        apply { this.ioScheduler = ioScheduler }

    /**
     * Sets the corruption handler to install into the DataStore.
     *
     * This parameter is optional and defaults to no corruption handler.
     *
     * @param corruptionHandler
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setCorruptionHandler(corruptionHandler: ReplaceFileCorruptionHandler<T>):
        RxDataStoreBuilder<T> = apply { this.corruptionHandler = corruptionHandler }

    /**
     * Add a DataMigration to the Datastore. Migrations are run in the order they are added.
     *
     * @param dataMigration the migration to add
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun addDataMigration(dataMigration: DataMigration<T>): RxDataStoreBuilder<T> = apply {
        this.dataMigrations.add(dataMigration)
    }

    /**
     * Build the DataStore.
     *
     * @throws IllegalStateException if serializer is not set or if neither produceFile not
     * context and name are set.
     * @return the DataStore with the provided parameters
     */
    public fun build(): DataStore<T> {
        check(serializer != null) {
            "Serializer must be set."
        }

        val scope = CoroutineScope(ioScheduler.asCoroutineDispatcher())

        return if (produceFile != null) {
            DataStoreFactory.create(
                produceFile = { produceFile!!.call() },
                serializer = serializer!!,
                scope = CoroutineScope(
                    ioScheduler.asCoroutineDispatcher()
                ),
                corruptionHandler = corruptionHandler,
                migrations = dataMigrations
            )
        } else if (context != null && name != null) {
            return context!!.createDataStore(
                fileName = name!!,
                serializer = serializer!!,
                scope = scope,
                corruptionHandler = corruptionHandler,
                migrations = dataMigrations
            )
        } else {
            throw IllegalStateException("Either produceFile or context and name must be set.")
        }
    }
}
